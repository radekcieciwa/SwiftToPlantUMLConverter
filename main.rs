extern crate serde_json;

use std::env;
use std::process::Command;
// use std::fmt;
use serde_json::Value;

const HEADER: &str = "' This diagram was generated by script.\n' Please do not alter the content.";

const CLASS_KEY: &str = "source.lang.swift.decl.class";
// const ENUM_KEY: &str = "source.lang.swift.decl.enum";
// const STRUCT_KEY: &str = "source.lang.swift.decl.struct";
const PROTOCOL_KEY: &str = "source.lang.swift.decl.protocol";

const VARIABLE_KEY: &str = "source.lang.swift.decl.var.instance";
// const ENUM_ELEM_KEY: &str = "source.lang.swift.decl.enumelement";
const FUNCTION_KEY: &str = "source.lang.swift.decl.function.method.instance";

const SUBSTRCTURE_KEY: &str = "key.substructure";
const INHERITED_TYPES_KEY: &str = "key.inheritedtypes";
const NAME_KEY: &str = "key.name";
const KIND_KEY: &str = "key.kind";
// const TYPE_NAME_KEY: &str = "key.typename"; // this is added to variables and parameters of function

const REL_INHERIT: &str = "--|>";

#[derive(Debug)]
enum Kind {
    Class,
    // Struct,
    // Enum,
    Protocol,
    Variable,
    Function,
    // Case,
}

#[derive(Debug)]
enum Token<'a> {
    // Kind, Name, Parents, Objects
    Type(Kind, &'a str, Vec<&'a str>, Vec<Token<'a>>),
    // Type(Kind, &'a str, Vec<&'a str>, Vec<&'a Token<'a>>),
    Object(Kind, &'a str),
}

// impl fmt::Display for Token {
//     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
//         match self {
//             Token::Type(kind, name, _, _) => { write!(f, "({}, {})", kind, name) },
//             Token::Object(kind, name) => { write!(f, "({}, {})", kind, name) }
//         }
//         // write!(f, "({}, {})", self.x, self.y)
//     }
// }

fn eval(json: &Value) -> Option<Token> {
    let mut inherited_items: Vec<&str> = Vec::new();
    let inherited_types = &json[INHERITED_TYPES_KEY].as_array();
    if inherited_types.is_some() {
        let inherited_types_unwrapped = inherited_types.unwrap();
        if inherited_types_unwrapped.len() > 0 {
            for inner in inherited_types_unwrapped {
                inherited_items.push(inner[NAME_KEY].as_str().unwrap());
            };
        };
    }

    let name = &json[NAME_KEY].as_str();
    let kind = &json[KIND_KEY].as_str();

    match (kind, name) {
        (Some(kind), Some(name)) => {
            // let name = name.to_string();
            match kind {
                &CLASS_KEY => Some(Token::Type(Kind::Class, name, inherited_items, Vec::new())),
                &PROTOCOL_KEY => Some(Token::Type(Kind::Protocol, name, inherited_items, Vec::new())),
                &VARIABLE_KEY => Some(Token::Object(Kind::Variable, name)),
                &FUNCTION_KEY => Some(Token::Object(Kind::Function, name)),
                _ => None,
            }
        },
        (Some(_x), None) => None,
        (_, _) => None,
    }
}

fn traverse(json: &Value) -> Vec<Token> {
    let mut sub_tokens: Vec<Token> = Vec::new();
    let inner_json: &Value = &json[SUBSTRCTURE_KEY];
    let inner_json_array = inner_json.as_array();
    if inner_json_array.is_some() {
        let inner_json_array_unwrapped = inner_json_array.unwrap();
        if inner_json_array_unwrapped.len() > 0 {
            for inner in inner_json_array_unwrapped {
                sub_tokens.append(&mut traverse(inner));
            };
        };
    }

    let me = eval(json);

    if me.is_some() {
        let me_unwrapped = me.unwrap();
        let mut objects: Vec<Token> = Vec::new();
        // let mut objects: Vec<&Token> = Vec::new();

        for sub_token in sub_tokens {
            match sub_token {
                Token::Type(_, _, _, _) => { },  // add to returned types (flat), as after resolving me, also concat names
                Token::Object(kind, name) => { objects.push(Token::Object(kind, name)) },
            }
        }

        match me_unwrapped {
            Token::Type(kind, name, parents, _) => { vec![Token::Type(kind, name, parents, objects)] },
            Token::Object(kind, name) => { vec![Token::Object(kind, name)] },
        }
    } else {
        sub_tokens
    }
}

fn convert_to_plant_umlformat(tokens: Vec<Token>) {

    for token in tokens {
        match token {
            Token::Type(kind, name, inherited_types, objects) => {
                match kind {
                    Kind::Protocol => { print!("interface {}", name); },
                    Kind::Class => { print!("class {}", name); },
                    _ => {}
                }

                if objects.len() > 0 {
                    println!(" {{");
                    for object in objects {
                        match object {
                            // TODO: Add checking on kind if it's function or variable
                            Token::Object(Kind::Variable, name) => { println!("\tvar {}", name); },
                            Token::Object(Kind::Function, name) => { println!("\tfunc {}", name); },
                            _ => { },
                        }
                    }
                    println!("}}");
                } else {
                    println!("");
                }

                for inherited_type in inherited_types {
                    println!("{} {} {}", name, &REL_INHERIT, inherited_type);
                }
            },
            // No Objects should be here at this point!
            // Token::Object(Kind::Variable, name) => { println!("Variable: {}", name); },
            // Token::Object(Kind::Function, name) => { println!("Function: {}", name); },
            _ => { },
        }
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();
    let file_path = &args[1];

    let files_output = Command::new("find")
        .arg(file_path)
        .arg("-print")
        // .arg("|")
        // .arg("grep")
        // .arg("swift")
        .output()
        .expect("failed to execute process");

    let files_list_output = String::from_utf8_lossy(&files_output.stdout);
    let files_list: Vec<&str> = files_list_output.split("\n").collect();
    let swift_files: Vec<&str> = files_list.iter().filter(|item| item.contains(".swift")).cloned().collect();
    // println!("{}", swift_files.join("\n"));

    // let results: Vec<&str> = swift_files.iter().map(|&a| { a }).collect();
    // println!("{}", results[0]);
    let file_structures: Vec<String> = swift_files.iter().map(|file_path| {
        let output = Command::new("sourcekitten")
            .arg("structure")
            .arg("--file")
            .arg(file_path)
            .output()
            .expect("failed to execute process");

        // let class_json_string = String::from_utf8_lossy(&output.stdout).to_str();
        return String::from_utf8(output.stdout).unwrap();
    }).collect::<Vec<_>>();

    println!("@startuml");
    println!("{}", HEADER);
    println!("");

    for content in file_structures {
        let json: Value = serde_json::from_str(&content).expect("Nooooo!");
        let traversed = traverse(&json);
        convert_to_plant_umlformat(traversed);
    }

    println!("");
    println!("@enduml");

    // results.iter().map(|content| {
    //
    // }).for_each(|tokens| );
    //
    // println!("{}", results[0]);

    // let output = Command::new("sourcekitten")
    //     .arg("structure")
    //     .arg("--file")
    //     .arg(file_path)
    //     .output()
    //     .expect("failed to execute process");
    //
    // let class_json_string = String::from_utf8_lossy(&output.stdout);
    // let json: Value = serde_json::from_str(&class_json_string).expect("Nooooo!");
    // let tokens = traverse(&json);
    // convert_to_plant_umlformat(tokens);
}
